# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://coffeescript.org/


#######################################
#
# Global variables (malpractice?)
#
#######################################

green_scale = d3.scale.linear().domain([0,1]).range(['grey', 'green'])
red_scale = d3.scale.linear().domain([0,1]).range(['grey', 'red'])
_scores = {}
_percentages = {}
_totals = {}
_max = 2012
_min = 2001
_index1 = 0
_index2 = 0
margins = {top: 50, right: 15, bottom: 20, left: 60}
width = 959
height = 593
pie_colors = undefined
chart_group = undefined
tooltip = undefined
translations = undefined
to_compare = []

###########################################
#
# Setting up (fire when ready!)
#
###########################################

$ ->
    chart_group = d3.select("#chart_group")
    width = d3.select('svg')[0][0].width.baseVal.value
    height = d3.select('svg')[0][0].height.baseVal.value
    pie_colors = gon.pie_colors
    translations = gon.translations

    for abbrev in gon.state_abbrevs
        calculate_scores(abbrev)
        calculate_percentages(abbrev)

    # setting up green-ness sliders
    for type, weight of gon.green
        $("##{type}_slider").slider({
            animate: true,
            max: 10,
            min: -10,
            step: .1,
            orientation: "vertical",
            value: weight,
            slide: (event, ui) ->
                change_green_val(ui.handle.parentElement.id.slice(0, -7), ui.value)
            })
        $("##{type}_input").on('change', (eventObject) ->
            change_green_val(this.id.slice(0, -6), this.value)
            )

    # setting up year slider
    $("#time").slider({
        animate: true,
        max: _max,
        min: _min,
        orientation: "horizontal",
        step: 1,
        value: _max,
        slide: (event, ui) ->
            $('#year').text("Year: #{ui.value}")
            _index1 = _max - ui.value
            update_bars()
            d3.selectAll("##{state}").attr('fill', fill_color(state)) for state in gon.state_abbrevs
        })

    $('#year').text("Year: #{_max} (change with the slider below)")

    d3.selectAll('.state')
        .attr('fill', 'white')
        .attr('stroke', 'white')
        .attr('stroke-width', '0.75')
        .on('mouseover', () ->
            state_hover(this.id)
        )
        .on('mouseleave', () ->
            state_unhover(this.id)
        )
        .on('click', () ->
            if to_compare.indexOf(this.id) == -1
                to_compare[to_compare.length] = this.id
            make_chart()
        )
        .transition()
            .duration(500)
            .delay( (d,i) ->
                i * 40
            )
            .attr('fill', () ->
                abbrev = this.id
                fill_color(abbrev)
            )

    tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)

    d3.select('body')
        .on('keydown', () ->
            show_map(false) if d3.event.keyCode == 27
        )

    $('#scale_absolute').on('click', update_bars)
    $('#scale_relative').on('click', update_bars)

    to_compare = ['WA', 'FL', 'TX']
    make_chart()

#######################################
#
# Score calculation
#
#######################################

# uses electricity generation data to determine fill color
# saves a time series of green-ness scores to all _* hashes
calculate_scores = (state) ->
    state_data = gon.elec_data[state]
    scores = []
    totals = []
    _max = 0
    for k, v of state_data # k is the type of energy, v is energy time series data
        unless typeof v == typeof ""
            _max = v[0][0] if v[0][0] > _max
            for i in [0...v.length] by 1 # each pair is a year and a number of gigawatt hours
                gigawatts = parseFloat(v[i][1])
                if $.isNumeric(gigawatts)
                    if gigawatts < 0
                        # console.log("#{state} sank #{gigawatts} into #{k} in year #{_max - i}")
                    else
                        unless $.isNumeric(scores[i])
                            scores[i] = 0
                        unless $.isNumeric(totals[i])  
                            totals[i] = 0
                        toAdd = gon.green[k]*gigawatts
                        scores[i] += toAdd
                        totals[i] += gigawatts
    _scores[state] = scores
    _totals[state] = totals

calculate_percentages = (state) ->
    state_data = gon.elec_data[state]
    totals = _totals[state]
    percentages = {}
    for k, v of state_data
        unless typeof v == typeof ""
            percentage_series = []
            for i in [0...v.length] by 1
                percentage_series[i] = v[i][1]/totals[i]*100
            percentages[k] = percentage_series
    _percentages[state] = percentages

###########################################
#
# Visual Manipulation (the changing of things)
#
###########################################

state_hover = (id) ->
    bring_to_top(id)
    d3.selectAll("##{id}")
        .attr('fill', fill_color(id))
        .transition().duration(200)
            .attr('stroke', 'black')
            .attr('stroke-width', '1.5')

state_unhover = (id) ->
    d3.selectAll("##{id}")
        .attr('fill', fill_color(id))
        .transition().duration(200)
            .attr('stroke', 'white')
            .attr('stroke-width', '0.75')

# what happens when someone changes a green-ness score
change_green_val = (type, value) ->
    $("##{type}_slider").slider("value", value)
    $("##{type}_input").val(value)
    gon.green[type] = value
    for state in gon.state_abbrevs
        calculate_scores(state) 
        d3.selectAll("##{state}").attr('fill', fill_color(state))

fill_color = (state) ->
    scores = _scores[state]
    totals = _totals[state]
    if scores[_index1] > 0
        color = green_scale(scores[_index1]/totals[_index1])
    else
        color = red_scale(-scores[_index1]/totals[_index1])
    return color

bring_to_top = (id_to_top) ->
    d3.selectAll('path').datum(-1)
    d3.select("##{id_to_top}").datum(1)
    d3.selectAll('path').sort().order()

show_map = (comparing) ->
    chart_group.selectAll('g').remove()
    chart_group.selectAll('rect').remove()
    chart_group.selectAll('text')
    d3.select('#close').remove()
    $('#controls').hide()
    d3.select('#compare').remove()
    d3.select('#controls_toggle')
    d3.selectAll('.legend_label').remove()
    d3.selectAll('.bar_label').remove()
    to_compare.length = 0 if not comparing

show_tooltip = () ->
    tooltip.transition()
        .duration(300)
        .style('opacity', 1)

tooltip_says = (text) ->
    tooltip
        .text(text)
        .style('left', "#{d3.event.pageX}px")
        .style('top', "#{d3.event.pageY}px")

hide_tooltip = () ->
    tooltip.transition()
        .duration(300)
        .style('opacity', 0)

legend_positions = (index) ->
    x = 125 * Math.floor(index/2) + 15
    y = 25 * (index % 2) + 5
    [x, y]

highlight_bars = (focused) ->
    labels = get_labels()
    for state_id in to_compare
        for label in labels
            bars = d3.select("##{state_id}_#{label}_bar")
            box = d3.select("##{label}_box")
            text = d3.select("##{label}_label")
            d3.select('#veil')
                .transition().duration(200)
                    .attr('opacity', .9)
            if focused.indexOf(label) > -1
                bars.transition().duration(150)
                    .attr('opacity', 1)
                box.transition().duration(200)
                    .attr('opacity', 1)
                text.transition().duration(200)
                    .attr('opacity', 1)
            else
                bars.transition().duration(150)
                    .attr('opacity', .1)
                box.transition().duration(200)
                    .attr('opacity', .2)
                text.transition().duration(200)
                    .attr('opacity', .2)

# shows all bars unless there are some focused, then only shows those
unhighlight_bars = () ->
    focused = get_focused()
    labels = get_labels()
    # some types are being focused
    if focused.length > 0
        highlight_bars(focused)
    # if no energy types have been focused on
    else
        d3.select('#veil')
            .transition().duration(700)
                .attr('opacity', .75)
        d3.selectAll('.legend_box')
            .transition().duration(200)
                .attr('opacity', 1)
        d3.selectAll('.bar')
            .transition().duration(150)
                .attr('opacity', 1)
        d3.selectAll('.legend_label')
            .transition().duration(200)
                .attr('opacity', 1)
    
update_bars = () ->
    absolute = get_absolute()
    x_scale = add_axis(absolute)
    for state_id in to_compare
        data = get_chart_data(state_id, absolute)
        labels = data[0]
        numbers = data[1]
        for label in labels
            d3.selectAll("##{state_id}_#{label}_bar")
                .datum(numbers[labels.indexOf(label)])
                .transition().duration(200)
                    # .delay( (d, i) ->
                    #     i * 50
                    # )
                    .attr('x', (d, i) ->
                        bar_x(numbers, labels.indexOf(label), x_scale)
                    )
                    .attr('width', (d, i) ->
                        x_scale(Math.abs(d))
                    )

toggle_controls = () ->
    controls = $('#controls')
    if controls.is(':visible')
        controls.hide()
    else
        controls.show()

###########################################
#
# Visual Setup (the placing of things)
#
###########################################

setup_chart = () ->
    chart_group.append('rect')
        .attr('id', 'veil')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'white')
        .attr('opacity', '0.75')

    chart_group.append('rect')
        .attr('id', 'top_stuff')
        .attr('width', width)
        .attr('height', margins['top'])
        .attr('fill', 'white')
        .attr('opacity', 0.75)

    add_legend()
    
    chart_group.append('text')
        .attr('id', 'close')
        .attr('x', 870)
        .attr('y', 580)
        .text("Close")
        .on('click', () -> show_map(false))

    chart_group.append('text')
        .attr('id', 'compare')
        .attr('x', 10)
        .attr('y', 580)
        .text('Compare')
        .attr('font-size', 25)
        .on('click', () -> show_map(true))

    chart_group.append('text')
        .attr('id', 'controls_toggle')
        .attr('x', 410)
        .attr('y', 580)
        .text('Controls')
        .on('click', toggle_controls)

add_legend = () ->
    index = 0
    for type, color of pie_colors
        positions = legend_positions(index)
        x = positions[0]
        y = positions[1]
        chart_group.append('rect')
            .datum(false)
            .attr('class', 'legend_box')
            .attr('id', "#{type}_box")
            .attr('fill', color)
            .attr('stroke', 'white')
            .attr('stroke-width', .75)
            .attr('width', 16)
            .attr('height', 16)
            .attr('x', () -> x )
            .attr('y', () -> y )
            .on('mouseover', () ->
                highlight_bars([this.id.slice(0, -4)])
            )
            .on('mouseleave', unhighlight_bars)
            .on('click', () ->
                focus_bars(this.id.slice(0, -4))
            )

        chart_group.append('text')
            .attr('class', 'legend_label')
            .attr('id', "#{type}_label")
            .text(translations[type])
            .attr('x', () -> x + 20 )
            .attr('y', () -> y + 13 )
            .attr('font-size', () ->
                smaller = ['pet_coke', 'pet_liquid', 'other_renew', 'other_gases']
                # console.log(type)
                if smaller.indexOf(this.id.slice(0, -6)) > -1
                    12
                else
                    17
            )
            .on('mouseover', () ->
                highlight_bars([this.id.slice(0, -6)])
            )
            .on('mouseleave', unhighlight_bars)
        index += 1


add_states = () ->
    chart_group.selectAll('g')
        .data(to_compare)
        .enter()
        .append('g')
            .attr('id', (d, i) ->
                d + "_bars"
            )

add_axis = (absolute) ->
    d3.select('.axis').remove()
    x_scale = get_x_scale(absolute)
    chart_group.append('g').call(
        d3.svg.axis()
            .scale(x_scale)
            .orient('bottom')
    )
        .attr('class', 'axis')
        .attr('transform', "translate(#{margins['left']}, #{margins['top']})")
    x_scale

add_bars = () ->
    absolute = get_absolute()
    x_scale = add_axis(absolute)
    for state_id in to_compare
        data = get_chart_data(state_id, absolute)
        labels = data[0]
        numbers = data[1]
        d3.select("##{state_id}_bars").selectAll('rect')
            .data(numbers)
            .enter()
            .append('rect')
                .attr('class', 'bar')
                .attr('id', (d, i) ->
                    "#{state_id}_#{labels[i]}_bar"
                )
                .attr('y', (d, i) ->
                    bar_y("#{state_id}_bars")
                )
                .attr('x', (d, i) ->
                    bar_x(numbers, i, x_scale)
                )
                .attr('width', () ->
                    0
                )
                .attr('height', 18)
                .attr('fill', (d, i) ->
                    pie_colors[labels[i]]
                )
                .attr('opacity', 1)
                .on('mouseover', () ->
                    highlight_bars([this.id.slice(3, -4)])
                )
                .on('mousemove', (d, i) ->
                    tooltip_says("#{translations[labels[i]]}: #{Math.round(d)}")
                )
                .on('click', () ->
                    focus_bars(this.id.slice(3, -4))
                )
                .on('mouseleave', unhighlight_bars)
                .transition().duration(500)
                    .delay( (d, i) ->
                        i * 50
                    )
                    .attr('width', (d, i) ->
                        x_scale(Math.abs(d))
                    )


add_labels = () ->
    for state_id in to_compare
        chart_group.append('text')
            .attr('id', "#{state_id}_label")
            .attr('class', 'bar_label')
            .attr('x', 0)
            .attr('y', () -> bar_y("#{state_id}_bars") + 18 )
            .text("#{state_id}")


###########################################
#
# Barchart Backend
#
###########################################

bar_x = (numbers, i, x_scale) ->
    start = margins['left']
    if numbers[i] > 0
        for j in [0...i] by 1
            start += x_scale(numbers[j]) if numbers[j] > 0
    else
        for j in [0..i] by 1
            start += x_scale(numbers[j]) if numbers[j] < 0
    start

get_chart_data = (state_id, absolute) ->
    labels = []
    numbers = []
    if absolute
        for type, series of gon.elec_data[state_id]
            labels[labels.length] = type
            to_append = series[_index1][1]
            to_append = 0 unless to_append # gets rid of undefined's
            numbers[numbers.length] = to_append
    else
        for type, series of _percentages[state_id]
            labels[labels.length] = type
            numbers[numbers.length] = series[_index1]
    return [labels, numbers]

get_labels = () ->
    labels = []
    for type, trans of translations
        labels[labels.length] = type
    labels

get_x_scale = (absolute) ->
    max = 0
    for state_id in to_compare
        sum = 0
        numbers = get_chart_data(state_id, absolute)[1]
        sum += Math.abs(num) for num in numbers
        max = sum if sum > max

    d3.scale.linear()
        .domain([0, max])
        .range([0, width - margins['left'] - margins['right']])

bar_y = (bar_id) ->
    num_bars = 1
    bar_num = 0
    for g in chart_group.selectAll('g')[0]
        if g.id
            bar_num = num_bars if g.id == bar_id
            num_bars += 1
    height * bar_num / num_bars

focus_bars = (type) ->
    box = d3.select("##{type}_box")
    box.datum(!box.datum())

get_focused = () ->
    toReturn = []
    labels = get_labels()
    for label in labels
        box = d3.select("##{label}_box")
        if box.datum()
            toReturn[toReturn.length] = label
    toReturn

get_absolute = () ->
    $('#scale_absolute').is(':checked')

# steps:
# 1) bring veil to front
# 2) add a group for the state, assign them data that will bring them to front (sort?)
# 3) add groups for each bar (make the attr the color the bar)
# 4) add rects to the above groups
make_chart = () ->
    setup_chart()
    add_states()
    add_bars()
    add_labels()
